// represents the whole program
program = { SOI ~ statement* ~ EOI }
// statements can be either have a terminator or not, depending on what you doing
statement           = { statement_without_term | statement_with_term }
statement_with_term = { (var_var | var_set | func_call) ~ term }
// function definition can have a scope block or an expression so it may or may not have a terminator
statement_without_term = { scope_block | func_def }

term      = { term_char+ }
term_char = { "!" }

scope_block = { "{" ~ statement* ~ "}" }

func_def = ${ func_start ~ ws+ ~ identifier ~ (ws+ ~ func_args? | ws+) ~ arrow ~ ws* ~ (scope_block | (expression ~ term)) }
// as long as any letter in function is used in order
func_start = ${ &("f" | "u" | "n" | "c" | "t" | "i" | "o" | "n") ~ "f"? ~ "u"? ~ "n"? ~ "c"? ~ "t"? ~ "i"? ~ "o"? ~ "n"? }
func_args  = !{ identifier ~ (comma ~ identifier)* }

arrow = _{ "=>" }
comma = _{ "," }

var_var        = ${ "var" ~ ws+ ~ "var" ~ ws+ ~ identifier ~ ws+ ~ "=" ~ ws+ ~ expression }
var_set        = ${ identifier ~ ws+ ~ "=" ~ ws+ ~ expression }
func_call      = ${ identifier ~ func_call_args? }
func_call_args = ${ ws+ ~ expression ~ (ws* ~ comma ~ ws* ~ expression)* }

// contains all the different types of expressions
// instead of brackets to define precedence, we combined number of whitespaces from the operator to the operands to define precedence
expression = ${ expr_atom ~ (ws* ~ expr_op ~ ws* ~ expr_atom)* }
expr_unary =  { logical_unary_not | math_unary_minus }
expr_atom  =  { (expr_unary ~ ws*)* ~ ws* ~ (var_or_string_or_func | var_or_value_or_func | func_call) }
expr_op    = _{ comp_strict_eq | comp_eq | comp_strict_ne | comp_ne | comp_le | comp_ge | comp_lt | comp_gt | logical_and | logical_or | math_add | math_sub | math_exp | math_mul | math_div | math_mod }
// the different types of operators
logical_unary_not = { ";" }
logical_and       = { "&&" }
logical_or        = { "||" }
comp_eq           = { "==" }
comp_strict_eq    = { "===" }
comp_ne           = { ";=" }
comp_strict_ne    = { ";==" }
comp_le           = { "<=" }
comp_ge           = { ">=" }
comp_lt           = { "<" }
comp_gt           = { ">" }
math_unary_minus  = { "-" }
math_add          = { "+" }
math_sub          = { "-" }
math_mul          = { "*" }
math_exp          = { "**" }
math_div          = { "/" }
math_mod          = { "%" }

// because we can define a variable with the same name as an integer, and we also can't tell if its a function without arguments
var_or_value_or_func = { identifier }

// because we can define stuff with the same name as a string
var_or_string_or_func = ${ string_surround ~ (string_escape | string_char)* ~ string_surround }
string_char           =  { !("\r" | "\n" | string_surround) ~ ANY }
string_escape         =  { "\\" ~ ("\"" | "\'" | "\\" | "n") }
// string_surround       =  { "\"" | "\'" }
string_surround = { "\"" }

identifier      = { identifier_char+ }
identifier_char = { !(ws | term_char | expr_unary | expr_op | arrow | comma) ~ ANY }

ws         =  { " " | "\t" | "\n" | "\r" | "(" | ")" }
WHITESPACE = _{ ws }
