// represents the whole program
program = { SOI ~ statement* ~ EOI }
// statements can be either have a terminator or not, depending on what you doing
statement           = { statement_with_term }
statement_with_term = { (var_var | func_call) ~ term }

term      = { term_char+ }
term_char = { "!" }

var_var        = ${ "var" ~ ws+ ~ "var" ~ ws+ ~ identifier ~ ws+ ~ "=" ~ ws+ ~ expression }
func_call      = ${ identifier ~ func_call_args? }
func_call_args = ${ ws+ ~ expression ~ (ws* ~ "," ~ ws* ~ expression)* }

// contains all the different types of expressions
// instead of brackets to define precedence, we combined number of whitespaces from the operator to the operands to define precedence
expression = ${ expr_atom ~ (ws* ~ expr_op ~ ws* ~ expr_atom)* }
expr_unary =  { logical_unary_not | math_unary_minus }
expr_atom  =  { (expr_unary ~ ws*)* ~ ws* ~ (var_or_value_or_func | func_call) }
expr_op    = _{ comp_eq | comp_ne | comp_le | comp_ge | comp_lt | comp_gt | logical_and | logical_or | math_add | math_sub | math_exp | math_mul | math_div | math_mod }
// the different types of operators
logical_unary_not = { ";" }
logical_and       = { "&&" }
logical_or        = { "||" }
comp_eq           = { "==" }
comp_ne           = { ";=" }
comp_le           = { "<=" }
comp_ge           = { ">=" }
comp_lt           = { "<" }
comp_gt           = { ">" }
math_unary_minus  = { "-" }
math_add          = { "+" }
math_sub          = { "-" }
math_mul          = { "*" }
math_exp          = { "**" }
math_div          = { "/" }
math_mod          = { "%" }

// because we can define a variable with the same name as an integer, and we also can't tell if its a function without arguments
var_or_value_or_func = { identifier }

identifier      = { identifier_char+ }
identifier_char = { !(ws | term_char | expr_unary | expr_op) ~ ANY }

ws         =  { " " | "\t" | "\n" | "\r" | "(" | ")" }
WHITESPACE = _{ ws }
