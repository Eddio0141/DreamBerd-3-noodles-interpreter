// represents the whole program
program = { SOI ~ statement* ~ EOI }
// statements can be either have a terminator or not, depending on what you doing
statement           = { statement_with_term }
statement_with_term = { (var_var | func_call) ~ term }

term      = { term_char+ }
term_char = { "!" }

var_var        = ${ "var" ~ ws+ ~ "var" ~ ws+ ~ identifier ~ ws+ ~ "=" ~ ws+ ~ expression }
func_call      = ${ identifier ~ func_call_args? }
func_call_args = ${ ws+ ~ expression ~ (ws* ~ "," ~ ws* ~ expression)* }

// contains all the different types of expressions
// instead of brackets to define precedence, we combined number of whitespaces from the operator to the operands to define precedence
expression = ${ expr_atom ~ (ws* ~ expr_op ~ ws* ~ expr_atom)* }
expr_unary =  { logical_expr_unary_not }
expr_atom  =  { expr_unary* ~ ws* ~ (var_or_value_or_func | func_call) }
expr_op    = _{ comp_eq | comp_ne | comp_le | comp_ge | comp_lt | comp_gt | logical_and | logical_or }
// the different types of operators
logical_expr_unary_not = { ";" }
logical_and            = { "&&" }
logical_or             = { "||" }
comp_eq                = { "==" }
comp_ne                = { ";=" }
comp_le                = { "<=" }
comp_ge                = { ">=" }
comp_lt                = { "<" }
comp_gt                = { ">" }

// because we can define a variable with the same name as an integer, and we also can't tell if its a function without arguments
var_or_value_or_func = { identifier }

identifier      = { identifier_char+ }
identifier_char = { !(ws | term_char | expr_unary | expr_op) ~ ANY }

ws         =  { " " | "\t" | "\n" | "\r" | "(" | ")" }
WHITESPACE = _{ ws }
